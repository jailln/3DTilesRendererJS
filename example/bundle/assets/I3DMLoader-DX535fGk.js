import{r as D,F as P,B as V,a as H}from"./readMagicBytes-C5ZyfJzm.js";import{L as v}from"./LoaderBase-QLlipkOW.js";import{j as E,k as F,aG as G,aH as Q,Q as j}from"./three.module-llkpyLgW.js";import{G as k}from"./GLTFLoader-KDqsLDsn.js";class $ extends v{parse(s){const n=new DataView(s),r=D(n);console.assert(r==="i3dm");const d=n.getUint32(4,!0);console.assert(d===1);const U=n.getUint32(8,!0);console.assert(U===s.byteLength);const A=n.getUint32(12,!0),w=n.getUint32(16,!0),o=n.getUint32(20,!0),f=n.getUint32(24,!0),g=n.getUint32(28,!0),T=32,M=s.slice(T,T+A+w),c=new P(M,0,A,w),e=T+A+w,i=s.slice(e,e+o+f),L=new V(i,c.getData("INSTANCES_LENGTH"),0,o,f),h=e+o+f,u=new Uint8Array(s,h,U-h);let m=null,O=null;if(g)m=u,O=Promise.resolve();else{const N=this.resolveExternalURL(H(u));O=fetch(N,this.fetchOptions).then(a=>{if(!a.ok)throw new Error(`I3DMLoaderBase : Failed to load file "${N}" with status ${a.status} : ${a.statusText}`);return a.arrayBuffer()}).then(a=>{m=new Uint8Array(a)})}return O.then(()=>({version:d,featureTable:c,batchTable:L,glbBytes:m}))}}const B=new E,I=new E,_=new E,C=new E,R=new j,y=new E,S=new F;class q extends ${constructor(s=G){super(),this.manager=s,this.adjustmentTransform=new F}resolveExternalURL(s){return this.manager.resolveURL(super.resolveExternalURL(s))}parse(s){return super.parse(s).then(n=>{const{featureTable:r,batchTable:d}=n,U=n.glbBytes.slice().buffer;return new Promise((A,w)=>{const o=this.fetchOptions,f=this.manager,g=f.getHandler("path.gltf")||new k(f);o.credentials==="include"&&o.mode==="cors"&&g.setCrossOrigin("use-credentials"),"credentials"in o&&g.setWithCredentials(o.credentials==="include"),o.headers&&g.setRequestHeader(o.headers);let T=this.workingPath;/[\\/]$/.test(T)||(T+="/");const M=this.adjustmentTransform;g.parse(U,T,c=>{const e=r.getData("INSTANCES_LENGTH"),i=r.getData("POSITION",e,"FLOAT","VEC3"),L=r.getData("NORMAL_UP",e,"FLOAT","VEC3"),h=r.getData("NORMAL_RIGHT",e,"FLOAT","VEC3"),u=r.getData("SCALE_NON_UNIFORM",e,"FLOAT","VEC3"),m=r.getData("SCALE",e,"FLOAT","SCALAR");["RTC_CENTER","QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","EAST_NORTH_UP","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach(t=>{t in r.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${t}" detected.`)});const O=new Map,N=[];c.scene.traverse(t=>{if(t.isMesh){const{geometry:l,material:p}=t,b=new Q(l,p,e);b.position.copy(t.position),b.rotation.copy(t.rotation),b.scale.copy(t.scale),N.push(b),O.set(t,b)}});const a=new E;for(let t=0;t<e;t++)a.x+=i[t*3+0]/e,a.y+=i[t*3+1]/e,a.z+=i[t*3+2]/e;O.forEach((t,l)=>{const p=l.parent;p&&(p.remove(l),p.add(t),t.updateMatrixWorld(),t.position.copy(a).applyMatrix4(t.matrixWorld))});for(let t=0;t<e;t++){C.set(i[t*3+0]-a.x,i[t*3+1]-a.y,i[t*3+2]-a.z),L?(I.set(L[t*3+0],L[t*3+1],L[t*3+2]),_.set(h[t*3+0],h[t*3+1],h[t*3+2]),B.crossVectors(_,I).normalize(),S.makeBasis(_,I,B),R.setFromRotationMatrix(S)):R.set(0,0,0,1),m?y.setScalar(m[t]):u?y.set(u[t*3+0],u[t*3+1],u[t*3+2]):y.set(1,1,1),S.compose(C,R,y).multiply(M);for(let l=0,p=N.length;l<p;l++)N[l].setMatrixAt(t,S)}c.batchTable=d,c.featureTable=r,c.scene.batchTable=d,c.scene.featureTable=r,A(c)},w)})})}}export{q as I};
