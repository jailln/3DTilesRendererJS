import{g as ot,az as nt,b as rt,V as S,k as et,l as at,j as f,m as it,E as ct,R as lt,Q as st,i as ht}from"./three.module-llkpyLgW.js";class pt extends ot{constructor(){super(new nt(0,0),new dt),this.renderOrder=1/0}onBeforeRender(t){const e=this.material.uniforms;t.getSize(e.resolution.value)}updateMatrixWorld(){this.matrixWorld.makeTranslation(this.position)}dispose(){this.geometry.dispose(),this.material.dispose()}}class dt extends rt{constructor(){super({depthWrite:!1,depthTest:!1,transparent:!0,uniforms:{resolution:{value:new S},size:{value:15},thickness:{value:2},opacity:{value:1}},vertexShader:`

				uniform float pixelRatio;
				uniform float size;
				uniform float thickness;
				uniform vec2 resolution;
				varying vec2 vUv;

				void main() {

					vUv = uv;

					float aspect = resolution.x / resolution.y;
					vec2 offset = uv * 2.0 - vec2( 1.0 );
					offset.y *= aspect;

					vec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					screenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;

					gl_Position = screenPoint;

				}
			`,fragmentShader:`

				uniform float size;
				uniform float thickness;
				uniform float opacity;

				varying vec2 vUv;
				void main() {

					float ht = 0.5 * thickness;
					float planeDim = size + thickness;
					float offset = ( planeDim - ht - 2.0 ) / planeDim;
					float texelThickness = ht / planeDim;

					vec2 vec = vUv * 2.0 - vec2( 1.0 );
					float dist = abs( length( vec ) - offset );
					float fw = fwidth( dist ) * 0.5;
					float a = smoothstep( texelThickness - fw, texelThickness + fw, dist );

					gl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );

				}
			`})}}class ut{constructor(){this.domElement=null,this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new S,this.hoverSet=!1}reset(){this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new S,this.hoverSet=!1}updateFrame(){const{previousPositions:t,pointerPositions:e}=this;for(const i in e)t[i].copy(e[i])}setHoverEvent(t){t.pointerType==="mouse"&&(this.getAdjustedPointer(t,this.hoverPosition),this.hoverSet=!0)}getLatestPoint(t){return this.pointerType!==null?(this.getCenterPoint(t),t):this.hoverSet?(t.copy(this.hoverPosition),t):null}getAdjustedPointer(t,e){const s=(this.domElement?this.domElement:t.target).getBoundingClientRect(),a=t.clientX-s.left,r=t.clientY-s.top;e.set(a,r)}addPointer(t){const e=t.pointerId,i=new S;this.getAdjustedPointer(t,i),this.pointerOrder.push(e),this.pointerPositions[e]=i,this.previousPositions[e]=i.clone(),this.startPositions[e]=i.clone(),this.getPointerCount()===1&&(this.pointerType=t.pointerType,this.buttons=t.buttons)}updatePointer(t){const e=t.pointerId;return e in this.pointerPositions?(this.getAdjustedPointer(t,this.pointerPositions[e]),!0):!1}deletePointer(t){const e=t.pointerId,i=this.pointerOrder;i.splice(i.indexOf(e),1),delete this.pointerPositions[e],delete this.previousPositions[e],delete this.startPositions[e],this.getPointerCount.length===0&&(this.buttons=0,this.pointerType=null)}getPointerCount(){return this.pointerOrder.length}getCenterPoint(t,e=this.pointerPositions){const i=this.pointerOrder;if(this.getPointerCount()===1||this.getPointerType()==="mouse"){const s=i[0];return t.copy(e[s]),t}else if(this.getPointerCount()===2){const s=this.pointerOrder[0],a=this.pointerOrder[1],r=e[s],c=e[a];return t.addVectors(r,c).multiplyScalar(.5),t}return null}getPreviousCenterPoint(t){return this.getCenterPoint(t,this.previousPositions)}getStartCenterPoint(t){return this.getCenterPoint(t,this.startPositions)}getPointerDistance(t=this.pointerPositions){if(this.getPointerCount()<=1||this.getPointerType()==="mouse")return 0;const{pointerOrder:e}=this,i=e[0],s=e[1],a=t[i],r=t[s];return a.distanceTo(r)}getPreviousPointerDistance(){return this.getPointerDistance(this.previousPositions)}getStartPointerDistance(){return this.getPointerDistance(this.startPositions)}getPointerType(){return this.pointerType}isPointerTouch(){return this.getPointerType()==="touch"}getPointerButtons(){return this.buttons}isLeftClicked(){return!!(this.buttons&1)}isRightClicked(){return!!(this.buttons&2)}}const C=new et,G=new at,N=new f;function U(p,t,e){return e.makeTranslation(-p.x,-p.y,-p.z),C.makeRotationFromQuaternion(t),e.premultiply(C),C.makeTranslation(p.x,p.y,p.z),e.premultiply(C),e}function b(p,t,e,i){i.x=(p-e.offsetLeft)/e.clientWidth*2-1,i.y=-((t-e.offsetTop)/e.clientHeight)*2+1,i.isVector3&&(i.z=0)}function vt(p,t,e){return t.intersectRay(p,e)?e:(C.makeScale(...t.radius).invert(),G.copy(p).applyMatrix4(C),N.set(0,0,0),G.closestPointToPoint(N,e).normalize(),C.makeScale(...t.radius),e.applyMatrix4(C))}function yt(p,t,e){const i=p.origin.length(),s=Math.acos(t/i);e.copy(p.origin).multiplyScalar(-1).normalize();const a=N.crossVectors(e,p.direction).normalize();e.multiplyScalar(-1).applyAxisAngle(a,-s).normalize().multiplyScalar(t)}function R(p,t,e){const{origin:i,direction:s}=p.ray;i.set(t.x,t.y,-1).unproject(e),s.set(t.x,t.y,0).unproject(e).sub(i).normalize(),p.camera=e}const _=0,E=1,w=2,A=3,W=4,V=.05,F=.025,z=new et,Q=new f,y=new f,H=new f,Y=new f,T=new f,M=new st,X=new it,g=new f,j=new f,I=new f,mt=new st,L=new S,d=new S,$=new S,Z=new S,B=new S,J=new S,ft={type:"change"},K={type:"start"},tt={type:"end"};class gt extends ct{get enabled(){return this._enabled}set enabled(t){t!==this.enabled&&(this.resetState(),this.pointerTracker.reset(),this._enabled=t)}constructor(t=null,e=null,i=null,s=null){super(),this.domElement=null,this.camera=null,this.scene=null,this.tilesRenderer=null,this._enabled=!0,this.cameraRadius=5,this.rotationSpeed=1,this.minAltitude=0,this.maxAltitude=.45*Math.PI,this.minDistance=10,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.zoomSpeed=1,this.adjustHeight=!0,this.reorientOnDrag=!0,this.scaleZoomOrientationAtEdges=!1,this.state=_,this.pointerTracker=new ut,this.needsUpdate=!1,this.actionHeightOffset=0,this.pivotPoint=new f,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.zoomDirection=new f,this.zoomPoint=new f,this.zoomDelta=0,this.pivotMesh=new pt,this.pivotMesh.raycast=()=>{},this.pivotMesh.scale.setScalar(.25),this.raycaster=new lt,this.raycaster.firstHitOnly=!0,this.up=new f(0,1,0),this.fallbackPlane=new it(new f(0,1,0),0),this.useFallbackPlane=!0,this._detachCallback=null,this._upInitialized=!1,this._lastUsedState=_,this._zoomPointWasSet=!1,this._tilesOnChangeCallback=()=>this.zoomPointSet=!1,i&&this.attach(i),e&&this.setCamera(e),t&&this.setScene(t),s&&this.setTilesRenderer(s)}setScene(t){this.scene=t}setCamera(t){this.camera=t,this._upInitialized=!1,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0,this.resetState()}setTilesRenderer(t){this.tilesRenderer&&this.tilesRenderer.removeEventListener("tile-visibility-change",this._tilesOnChangeCallback),this.tilesRenderer=t,this.tilesRenderer!==null&&(this.tilesRenderer.addEventListener("tile-visibility-change",this._tilesOnChangeCallback),this.scene===null&&this.setScene(this.tilesRenderer.group))}attach(t){if(this.domElement)throw new Error("EnvironmentControls: Controls already attached to element");this.domElement=t,this.pointerTracker.domElement=t,t.style.touchAction="none";let e=!1;const i=o=>{o.preventDefault()},s=o=>{o.key==="Shift"&&(e=!0)},a=o=>{o.key==="Shift"&&(e=!1)},r=o=>{o.preventDefault();const{camera:n,raycaster:h,domElement:P,up:k,pivotMesh:D,pointerTracker:v}=this;if(v.addPointer(o),this.needsUpdate=!0,v.isPointerTouch()){if(D.visible=!1,v.getPointerCount()===0)P.setPointerCapture(o.pointerId);else if(v.getPointerCount()>2){this.resetState();return}}v.getCenterPoint(d),b(d.x,d.y,P,d),R(h,d,n);const q=Math.abs(h.ray.direction.dot(k));if(q<V||q<F)return;const O=this._raycast(h);O&&(v.getPointerCount()===2||v.isRightClicked()||v.isLeftClicked()&&e?(this.setState(v.isPointerTouch()?W:w),this.pivotPoint.copy(O.point),this.pivotMesh.position.copy(O.point),this.pivotMesh.updateMatrixWorld(),this.scene.add(this.pivotMesh)):v.isLeftClicked()&&(this.setState(E),this.pivotPoint.copy(O.point),this.pivotMesh.position.copy(O.point),this.pivotMesh.updateMatrixWorld(),this.scene.add(this.pivotMesh)))};let c=!1;const l=o=>{o.preventDefault(),this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0;const{pointerTracker:n}=this;n.setHoverEvent(o),n.updatePointer(o)&&n.isPointerTouch()&&n.getPointerCount()===2&&(c||(c=!0,queueMicrotask(()=>{c=!1,n.getCenterPoint(B);const h=n.getStartPointerDistance(),P=n.getPointerDistance(),k=P-h;if(this.state===_||this.state===W){n.getCenterPoint(B),n.getStartCenterPoint(J);const D=2*window.devicePixelRatio,v=B.distanceTo(J);(Math.abs(k)>D||v>D)&&(Math.abs(k)>v?(this.setState(A),this.zoomDirectionSet=!1):this.setState(w))}if(this.state===A){const D=n.getPreviousPointerDistance();this.zoomDelta+=P-D}else this.state===w&&(this.pivotMesh.visible=!0)})))},u=o=>{const{pointerTracker:n}=this;n.deletePointer(o),n.getPointerType()==="touch"&&n.getPointerCount()===0&&t.releasePointerCapture(o.pointerId),this.resetState(),this.needsUpdate=!0},m=o=>{o.preventDefault();const{pointerTracker:n}=this;n.setHoverEvent(o),n.updatePointer(o),this.dispatchEvent(K);let h;switch(o.deltaMode){case 2:h=o.deltaY*100;break;case 1:h=o.deltaY*16;break;case 0:h=o.deltaY;break}const P=Math.sign(h),k=Math.log(Math.abs(h)+1);this.zoomDelta-=3*P*k,this.needsUpdate=!0,this._lastUsedState=A,this.dispatchEvent(tt)},x=o=>{const{pointerTracker:n}=this;e=!1,o.buttons!==n.getPointerButtons()&&(n.deletePointer(o),this.resetState())};t.addEventListener("contextmenu",i),t.addEventListener("keydown",s),t.addEventListener("keyup",a),t.addEventListener("pointerdown",r),t.addEventListener("pointermove",l),t.addEventListener("pointerup",u),t.addEventListener("wheel",m),t.addEventListener("pointerenter",x),this._detachCallback=()=>{t.removeEventListener("contextmenu",i),t.removeEventListener("keydown",s),t.removeEventListener("keyup",a),t.removeEventListener("pointerdown",r),t.removeEventListener("pointermove",l),t.removeEventListener("pointerup",u),t.removeEventListener("wheel",m),t.removeEventListener("pointerenter",x)}}getUpDirection(t,e){e.copy(this.up)}getCameraUpDirection(t){this.getUpDirection(this.camera.position,t)}getPivotPoint(t){return this._lastUsedState===A?this._zoomPointWasSet?(t.copy(this.zoomPoint),t):null:this._lastUsedState===w||this._lastUsedState===E?(t.copy(this.pivotPoint),t):null}detach(){this.domElement=null,this._detachCallback&&(this._detachCallback(),this._detachCallback=null,this.pointerTracker.reset())}resetState(){this.state!==_&&this.dispatchEvent(tt),this.state=_,this.pivotMesh.removeFromParent(),this.pivotMesh.visible=!0,this.actionHeightOffset=0}setState(t=this.state,e=!0){this.state!==t&&(this.state===_&&e&&this.dispatchEvent(K),this.state=t,t!==_&&t!==W&&(this._lastUsedState=t))}update(){if(!this.enabled||!this.camera)return;const{camera:t,cameraRadius:e,pivotPoint:i,up:s,state:a,adjustHeight:r}=this;if(this.needsUpdate){const u=a,m=this.zoomDelta;u===E&&this._updatePosition(),u===w&&this._updateRotation(),(u===A||m!==0)&&this._updateZoom(),(u!==_||m!==0)&&this.dispatchEvent(ft),this.needsUpdate=!1}const c=t.isOrthographicCamera?null:r&&this._getPointBelowCamera()||null,l=t.isOrthographicCamera?i:c&&c.point||null;if(this.getCameraUpDirection(g),this._upInitialized?this._setFrame(g,l):(this._upInitialized=!0,this.up.copy(g)),(this.state===E||this.state===w)&&this.actionHeightOffset!==0){const{actionHeightOffset:u}=this;t.position.addScaledVector(s,-u),i.addScaledVector(s,-u),c&&(c.distance-=u)}if(this.actionHeightOffset=0,c){const u=c.distance;if(u<e){const m=e-u;t.position.addScaledVector(s,m),i.addScaledVector(s,m),this.actionHeightOffset=m}}this.pointerTracker.updateFrame()}dispose(){this.detach()}_updateZoom(){const{zoomPoint:t,zoomDirection:e,camera:i,minDistance:s,maxDistance:a,raycaster:r,pointerTracker:c,domElement:l,minZoom:u,maxZoom:m,zoomSpeed:x}=this;let o=this.zoomDelta;if(this.zoomDelta=0,!!c.getLatestPoint(d))if(i.isOrthographicCamera)if(b(d.x,d.y,l,j),R(r,d,i),e.copy(r.ray.direction).normalize(),this.zoomDirectionSet=!0,this.zoomPointSet||this._updateZoomPoint()){j.unproject(i);const n=Math.pow(.95,Math.abs(o*.05)),h=o>0?1/Math.abs(n):n;i.zoom=Math.max(u,Math.min(m,i.zoom*h*x)),i.updateProjectionMatrix(),b(d.x,d.y,l,I),I.unproject(i),i.position.sub(I).add(j),i.updateMatrixWorld()}else{const n=Math.pow(.95,Math.abs(o*.05)),h=o>0?1/Math.abs(n):n;i.zoom=Math.max(u,Math.min(m,i.zoom*h*x)),i.updateProjectionMatrix()}else{b(d.x,d.y,l,d),R(r,d,i),e.copy(r.ray.direction).normalize(),this.zoomDirectionSet=!0;const n=y.copy(e);if(this.zoomPointSet||this._updateZoomPoint()){const h=t.distanceTo(i.position);if(o<0){const P=Math.min(0,h-a);o=o*h*x*.0025,o=Math.max(o,P)}else{const P=Math.max(0,h-s);o=o*(h-s)*x*.0025,o=Math.min(o,P)}i.position.addScaledVector(e,o),i.updateMatrixWorld()}else{const h=this._getPointBelowCamera();if(h){const P=h.distance;n.set(0,0,-1).transformDirection(i.matrixWorld),i.position.addScaledVector(n,o*P*.01),i.updateMatrixWorld()}}}}_updateZoomPoint(){const{camera:t,zoomDirectionSet:e,zoomDirection:i,raycaster:s,zoomPoint:a,pointerTracker:r,domElement:c}=this;if(this._zoomPointWasSet=!1,!e)return!1;t.isOrthographicCamera&&r.getLatestPoint(L)?(b(L.x,L.y,c,L),R(s,L,t)):(s.ray.origin.copy(t.position),s.ray.direction.copy(i));const l=this._raycast(s);return l?(a.copy(l.point),this.zoomPointSet=!0,this._zoomPointWasSet=!0,!0):!1}_getPointBelowCamera(){const{camera:t,raycaster:e,up:i}=this;e.ray.direction.copy(i).multiplyScalar(-1),e.ray.origin.copy(t.position).addScaledVector(i,1e5);const s=this._raycast(e);return s&&(s.distance-=1e5),s}_updatePosition(){const{raycaster:t,camera:e,pivotPoint:i,up:s,pointerTracker:a,domElement:r}=this;if(a.getCenterPoint(d),b(d.x,d.y,r,d),X.setFromNormalAndCoplanarPoint(s,i),R(t,d,e),Math.abs(t.ray.direction.dot(s))<V){const c=Math.acos(V);T.crossVectors(t.ray.direction,s).normalize(),t.ray.direction.copy(s).applyAxisAngle(T,c).multiplyScalar(-1)}if(this.getUpDirection(i,g),Math.abs(t.ray.direction.dot(g))<F){const c=Math.acos(F);T.crossVectors(t.ray.direction,g).normalize(),t.ray.direction.copy(g).applyAxisAngle(T,c).multiplyScalar(-1)}t.ray.intersectPlane(X,y)&&(Q.subVectors(i,y),this.camera.position.add(Q),this.camera.updateMatrixWorld())}_updateRotation(){const{camera:t,pivotPoint:e,minAltitude:i,maxAltitude:s,pointerTracker:a,rotationSpeed:r}=this;a.getCenterPoint(d),a.getPreviousCenterPoint($),Z.subVectors(d,$).multiplyScalar(.02/devicePixelRatio);const c=-Z.x*r;let l=Z.y*r;H.set(0,0,-1).transformDirection(t.matrixWorld).multiplyScalar(-1),this.getUpDirection(e,g),y.crossVectors(g,H).normalize(),Y.set(1,0,0).transformDirection(t.matrixWorld).normalize();const m=Math.sign(y.dot(Y))*g.angleTo(H);l>0?(l=Math.min(m-i-.01,l),l=Math.max(0,l)):(l=Math.max(m-s,l),l=Math.min(0,l)),M.setFromAxisAngle(g,c),U(e,M,z),t.matrixWorld.premultiply(z),T.set(-1,0,0).transformDirection(t.matrixWorld),M.setFromAxisAngle(T,l),U(e,M,z),t.matrixWorld.premultiply(z),t.matrixWorld.decompose(t.position,t.quaternion,y)}_setFrame(t,e){const{up:i,camera:s,state:a,zoomPoint:r,zoomDirection:c,zoomDirectionSet:l,zoomPointSet:u,reorientOnDrag:m,scaleZoomOrientationAtEdges:x}=this;s.updateMatrixWorld(),M.setFromUnitVectors(i,t);const o=a;if(l&&(u||this._updateZoomPoint())){if(this.getUpDirection(r,y),x){let n=Math.max(y.dot(i)-.6,0)/.4;n=ht.mapLinear(n,0,.5,0,1),n=Math.min(n,1),s.isOrthographicCamera&&(n*=.1),M.slerp(mt,1-n)}U(r,M,z),s.matrixWorld.premultiply(z),s.matrixWorld.decompose(s.position,s.quaternion,y),c.subVectors(r,s.position).normalize()}else o===E&&m&&e&&(U(e,M,z),s.matrixWorld.premultiply(z),s.matrixWorld.decompose(s.position,s.quaternion,y));i.copy(t),s.updateMatrixWorld()}_raycast(t){const{scene:e,useFallbackPlane:i,fallbackPlane:s}=this,a=t.intersectObject(e)[0]||null;if(a)return a;if(i){const r=s;if(t.ray.intersectPlane(r,y))return{point:y.clone(),distance:t.ray.origin.distanceTo(y)}}return null}}export{gt as E,_ as N,yt as a,U as b,vt as c,b as m,R as s};
