import{j as m,E as O,a as v,p as E,O as F,i as c}from"./three.module-llkpyLgW.js";const e=new m,s=new m,P=new m;function S(C){return 1-(Math.cos(Math.PI*C)+1)/2}class j extends O{get animating(){return this._alpha!==0&&this._alpha!==1}get camera(){return this._alpha===0?this.perspectiveCamera:this._alpha===1?this.orthographicCamera:this.transitionCamera}constructor(a=new v,o=new F){super(),this.perspectiveCamera=a,this.orthographicCamera=o,this.transitionCamera=new v,this.orthographicPositionalZoom=!0,this.orthographicOffset=50,this.fixedPoint=new m,this.duration=200,this._target=0,this._alpha=0,this._clock=new E}toggle(){this._target=this._target===1?0:1}update(){const{perspectiveCamera:a,orthographicCamera:o,transitionCamera:t,camera:n}=this,h=this._clock.getDelta()*1e3;if(this._syncCameras(),this._alpha!==this._target){const d=Math.sign(this._target-this._alpha)*h/this.duration;this._alpha=c.clamp(this._alpha+d,0,1),this.dispatchEvent({type:"change"})}const p=n;let r=null;this._alpha===0?r=a:this._alpha===1?r=o:(r=t,this._updateTransitionCamera()),p!==r&&this.dispatchEvent({type:"camera-changed",camera:r,prevCamera:p})}_syncCameras(){const a=this._getFromCamera(),{perspectiveCamera:o,orthographicCamera:t,transitionCamera:n,fixedPoint:i}=this;if(e.set(0,0,-1).transformDirection(a.matrixWorld).normalize(),a.isPerspectiveCamera){if(this.orthographicPositionalZoom)t.position.copy(o.position).addScaledVector(e,-this.orthographicOffset),t.rotation.copy(o.rotation),t.updateMatrixWorld();else{const l=s.subVectors(i,t.position).dot(e),d=s.subVectors(i,o.position).dot(e);s.copy(o.position).addScaledVector(e,d),t.rotation.copy(o.rotation),t.position.copy(s).addScaledVector(e,-l),t.updateMatrixWorld()}const h=Math.abs(s.subVectors(o.position,i).dot(e)),p=2*Math.tan(c.DEG2RAD*o.fov*.5)*h,r=t.top-t.bottom;t.zoom=r/p,t.updateProjectionMatrix()}else{const h=Math.abs(s.subVectors(t.position,i).dot(e)),r=(t.top-t.bottom)/t.zoom*.5/Math.tan(c.DEG2RAD*o.fov*.5);o.rotation.copy(t.rotation),o.position.copy(t.position).addScaledVector(e,h).addScaledVector(e,-r),o.updateMatrixWorld(),this.orthographicPositionalZoom&&(t.position.copy(o.position).addScaledVector(e,-this.orthographicOffset),t.updateMatrixWorld())}n.position.copy(o.position),n.rotation.copy(o.rotation)}_getTransitionDirection(){return Math.sign(this._target-this._alpha)}_getToCamera(){const a=this._getTransitionDirection();return a===0?this._target===0?this.perspectiveCamera:this.orthographicCamera:a>0?this.orthographicCamera:this.perspectiveCamera}_getFromCamera(){const a=this._getTransitionDirection();return a===0?this._target===0?this.perspectiveCamera:this.orthographicCamera:a>0?this.perspectiveCamera:this.orthographicCamera}_updateTransitionCamera(){const{perspectiveCamera:a,orthographicCamera:o,transitionCamera:t,fixedPoint:n}=this,i=S(this._alpha);e.set(0,0,-1).transformDirection(a.matrixWorld).normalize();const h=Math.abs(s.subVectors(a.position,n).dot(e)),p=2*Math.tan(c.DEG2RAD*a.fov*.5)*h,r=c.lerp(a.fov,1,i),l=p*.5/Math.tan(c.DEG2RAD*r*.5),d=0,M=o.far-o.near;P.copy(o.position).addScaledVector(e,o.near);const g=Math.abs(s.subVectors(a.position,n).dot(e)),f=Math.abs(s.subVectors(P,n).dot(e)),D=g-a.near,y=f-d,V=c.lerp(D,y,i),x=g-a.far,b=f-M,T=c.lerp(x,b,i),u=l-V,_=l-T,w=_-u;t.aspect=a.aspect,t.fov=r,t.near=Math.max(u,w*1e-5),t.far=_,t.position.copy(a.position).addScaledVector(e,g-l),t.rotation.copy(a.rotation),t.updateProjectionMatrix(),t.updateMatrixWorld()}}export{j as C};
